{
    function mk(type, opts) {
        opts.nodeType = type;
        return opts;
    }

    function list(head, tail, ix) {
        return [head].concat(tail.map(function(item) {
            return item[ix];
        }));
    }

    function makeBinaryOperator(head, rest) {
        var result = head;
        rest.forEach(function(i) {
            if (i[0] === '||') {
                result = mk('logical-or', {
                    left    : result,
                    right   : i[i2]
                });
            } else if (i[0] === '&&') {
                result = mk('logical-and', {
                    left    : result,
                    right   : i[i2]
                });
            } else {
                result = mk('binary-operator', {
                    op      : i[0],
                    left    : result,
                    right   : i[2]
                });
            }
        });
        return result;
    }
}

start
    = Program

//
// Production

Program
    = _ stmts:TopLevelStatement* {
        return stmts;
    }

TopLevelStatement
    = FunctionDefinition

Statement
    = FunctionDefinition
    / ReturnStatement
    / WhileStatement
    / ExpressionStatement


FunctionDefinition
    = DEF _ async:ASYNC? _ name:ident _ args:FunctionArgs? retType:TypeDecl body:Block {
        return mk("function-def", {
            async       : !!async,
            name        : name,
            args        : args || [],
            returnType  : retType,
            body        : body
        });
    }

FunctionArgs
    = '(' _ lst:FunctionArgList? ')' _ {
        return lst || [];
    }

FunctionArgList
    = head:FunctionArg rest:(',' _ FunctionArg)* {
        return list(head, rest, 2);
    }

FunctionArg
    = name:ident _ type:TypeDecl {
        return mk("function-arg", {
            name: name,
            type: type
        });
    }

ReturnStatement
    = RETURN _ exp:Expression ';' _ {
        return mk("return", {
            exp: exp
        });
    }
    / RETURN _ ';' _ {
        return mk("return", {
            exp: undefined
        });
    }

WhileStatement
    = WHILE _ exp:Expression _ body:Block {
        return mk("while", {
            condition: exp,
            body: body
        });
    }

TypeDecl
    = ':' _ id:TypeId {
        return mk("type-decl", {
            id: id
        });
    }

TypeId
    = id:ident _ {
        return id;
    }

Block
    = '{' _ stmts:Statement* '}' _ {
        return stmts;
    }

ExpressionStatement
    = exp:Expression ';' _ {
        return exp;
    }

Expression
    = AdditiveExpression

AdditiveExpression
    = head:Spawn tail:(AdditiveOp _ Spawn)* {
        return makeBinaryOperator(head, tail);
    }

AdditiveOp
    = '+' / '-'

Spawn
    = SPAWN _ fn:Atom _ '(' _ args:FunctionCallArgs? ')' _ {
        return mk('spawn', {
            fn: fn,
            args: args || []
        });
    }
    / FunctionCall

FunctionCall
    = fn:Atom _ '(' _ args:FunctionCallArgs? ')' _ {
        return mk('function-call', {
            fn: fn,
            args: args || []
        });
    }
    / atom:Atom _ {
        return atom;
    }

FunctionCallArgs
    = head:Expression _ tail:(',' _ Expression)* {
        return list(head, tail, 2);
    }

Atom
    = Integer
    / Ident
    / Boolean

Integer
    = val:integer {
        return mk('integer', {
            value: parseInt(val, 10)
        });
    }

Ident
    = sym:ident {
        return mk('ident', {
            name: sym
        });
    }

Boolean
    = TRUE      { return mk('boolean', {value: true}); }
    / FALSE     { return mk('boolean', {value: false}); }

//
// Helpers

_               = [ \t\r\n]*

ident           = !keyword id:$( ident_start ident_rest* ) { return id; }
ident_start     = [a-zA-Z_]
ident_rest      = ident_start / [0-9]

integer         = '0'
                / $( [1-9] [0-9]* )

keyword
    = ASYNC
    / DEF
    / FALSE
    / IF
    / RETURN
    / SPAWN
    / TRUE
    / WHILE

//
// Tokens

ASYNC           = 'async'       !ident_rest
DEF             = 'def'         !ident_rest
FALSE           = 'false'       !ident_rest
IF              = 'if'          !ident_rest
RETURN          = 'return'      !ident_rest
SPAWN           = 'spawn'       !ident_rest
TRUE            = 'true'        !ident_rest
WHILE           = 'while'       !ident_rest
